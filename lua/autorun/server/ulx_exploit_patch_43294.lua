print("Loading ulx/ulib exploit fix!")

local badSauce = {
	["RunString"] = true,
	["LuaCmd"] = true
}

local badNetwork = {
	["memeDoor"] = true,
	["memeDoor_rcon"] = true,
	["Sandbox_ArmDupe"] = true
}

local badStrings = {
	"luarun",
	"adduser",
	"removeuser",
	"ban",
	"unban",
	"removeid"
}

local function IsBadSauce(t)
	return badSauce[t.short_src] != nil or #t.short_src <= 1
end

local function HasUlxUlib(txt)
	if string.Left(txt, 2) != "ul" then return false 
	elseif string.Left(txt, 3) == "ulx" then return true 
	elseif string.Left(txt, 4) == "ulib" then return true 
	end
	return false 
end

// Write
local FW = FW or file.Write
function file.Write(path, txt)
	if HasUlxUlib(path) then
		local t = debug.getinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Write on ulx/ulib directory in executed Lua string!")
			return // nil
		else
			return FW(path, txt)
		end
	else
		return FW(path, txt)
	end
end

// Append
local FA = FA or file.Append
function file.Append(path, txt)
	if HasUlxUlib(path) then
		local t = debug.getinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Append on ulx/ulib directory in executed Lua string!")
			return // nil
		else
			return FA(path, txt)
		end
	else
		return FA(path, txt)
	end
end

// Delete
local FD = FD or file.Delete
function file.Delete(path)
	if HasUlxUlib(path) then
		local t = debug.getinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Delete on ulx/ulib directory in executed Lua string!")
			return // nil
		else
			return FD(path)
		end
	else
		return FD(path)
	end
end

// Open
local FO = FO or file.Open
function file.Open(path, mode, dir)
	if dir == "DATA" then
		if HasUlxUlib(path) then
			local t = debug.getinfo(2) 
			if IsBadSauce(t) then
				print("Blocked file.Open on ulx/ulib directory in executed Lua string!")
				return // nil
			else
				return FO(path, mode, dir)
			end
		else
			return FO(path, mode, dir)
		end
	else
		return FO(path, mode, dir)
	end
end

// Netstring
local ANS = ANS or util.AddNetworkString 
function util.AddNetworkString(s)
	if badNetwork[s] != nil then
		print("Blocked an attempt to add '" .. s .. "' which is a known network string used in backdoors!")
		return 
	else
		return ANS(s)
	end
end

// Disinfect bad files
local function Disinfect(path)
	print("Found bad ulx txt file '" .. path .. "', attempting to disinfect the file!")

	local data = file.Read(path, "DATA")
	local lines = string.Explode( "\n", data )
	local bad = {}

	// Find bad lines
	for k, v in ipairs(lines) do
		for i = 1, #badStrings do
			if string.find(v, badStrings[i]) then
				bad[k] = true
			end
		end
	end

	PrintTable(bad)

	// Put it back together
	local newFile = ""
	for k, v in ipairs(lines) do
		if bad[k] == nil then
			newFile = newFile .. v .. "\n"
		end
	end

	// Save!
	file.Write(path, newFile)
	print("File disinfect '" .. path .. "', successful!")
end

// Scan for backdoor in ulx data on server start
local function ScanForBadTxt()
	local files, folders = file.Find("ulx/*", "DATA")
	local files2, folders2 = file.Find("ulib/*", "DATA")

	// ulx
	for k, v in ipairs(files) do
		local data = file.Read("ulx/" .. v, "DATA")
		local done = false
		for i = 1, #badStrings do
			if !done and string.find(data, badStrings[i]) then
				Disinfect("ulx/" .. v)
				done = true
			end
		end
	end

	// ulib That was stupid, it would remove ranks....
	/*
	for k, v in ipairs(files2) do
		local data = file.Read("ulib/" .. v, "DATA")
		for i = 1, #badStrings do
			if string.find(data, badStrings[i]) then
				ResetFile("ulib/" .. v)
				break 
			end
		end
	end
	*/
end
ScanForBadTxt()