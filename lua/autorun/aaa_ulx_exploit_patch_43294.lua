if !SERVER then return end
print("Loading Ulx exploit patch!")

// Tables
local badSauce = {
	["RunString"] = true,
	["LuaCmd"] = true,
	["lua_run"] = true
}

local badNetwork = {
	["memeDoor"] = true,
	["memeDoor_rcon"] = true,
	["Sandbox_ArmDupe"] = true
}

local badStrings = {
	"luarun",
	"adduser",
	"removeuser",
	"ban",
	"unban",
	"removeid"
}

local scanFiles = {
	"ulx/config.txt"
}

// Locals
local fileExists = file.Exists
local fileRead = file.Read
local debuggetinfo = debug.getinfo

// Detours
local ANS = ANS or util.AddNetworkString 
local FW = FW or file.Write
local FA = FA or file.Append
local FD = FD or file.Delete
local FO = FO or file.Open


local function IsBadSauce(t)
	return badSauce[t.short_src] != nil or #t.short_src <= 1
end

local function HasUlxUlib(txt)
	if string.Left(txt, 2) != "ul" then return false 
	elseif string.Left(txt, 3) == "ulx" then return true 
	elseif string.Left(txt, 4) == "ulib" then return true 
	end
	return false 
end

// Write
function file.Write(path, txt)
	if HasUlxUlib(path) then
		local t = debuggetinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Write on '" .. path .. "' directory in executed Lua string!")
			return // nil
		else
			return FW(path, txt)
		end
	else
		return FW(path, txt)
	end
end

// Append
function file.Append(path, txt)
	if HasUlxUlib(path) then
		local t = debuggetinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Append on '" .. path .. "' directory in executed Lua string!")
			return // nil
		else
			return FA(path, txt)
		end
	else
		return FA(path, txt)
	end
end

// Delete
function file.Delete(path)
	if HasUlxUlib(path) then
		local t = debuggetinfo(2) 
		if IsBadSauce(t) then
			print("Blocked file.Delete on '" .. path .. "' directory in executed Lua string!")
			return // nil
		else
			return FD(path)
		end
	else
		return FD(path)
	end
end

// Open
function file.Open(path, mode, dir)
	if dir == "DATA" then
		if HasUlxUlib(path) then
			local t = debuggetinfo(2) 
			if IsBadSauce(t) then
				print("Blocked file.Open on '" .. path .. "' directory in executed Lua string!")
				return // nil
			else
				return FO(path, mode, dir)
			end
		else
			return FO(path, mode, dir)
		end
	else
		return FO(path, mode, dir)
	end
end

// Netstring
function util.AddNetworkString(s)
	if badNetwork[s] != nil then
		print("Blocked an attempt to add '" .. s .. "' which is a known network string used in backdoors!")
		return 
	else
		local t = debuggetinfo(2) 
		if IsBadSauce(t) then
			print("Blocked util.AddNetworkString '" .. s .. "' as it was executed in a Lua string!")
			return // nil
		else
			return ANS(s)
		end
	end
end

// Disinfect bad files
local function Disinfect(path)
	print("Found bad ulx txt file '" .. path .. "', attempting to disinfect the file!")

	local data = fileRead(path, "DATA")
	local lines = string.Explode( "\n", data )
	local bad = {}

	// Find bad lines
	for k, v in ipairs(lines) do
		for i = 1, #badStrings do
			if string.find(v, badStrings[i]) then
				bad[k] = true
			end
		end
	end

	// Put it back together
	local newFile = ""
	for k, v in ipairs(lines) do
		if bad[k] == nil then
			newFile = newFile .. v .. "\n"
		end
	end

	// Save!
	FW(path, newFile)
	print("File disinfect '" .. path .. "', successful!")
end

// Scan for backdoor in ulx data on server start
local function ScanForBadTxt()

	// ulx
	for k, v in ipairs(scanFiles) do
		if !fileExists(v, "DATA") then return end
		local data = fileRead(v, "DATA")
		local done = false
		for i = 1, #badStrings do
			if !done and string.find(data, badStrings[i]) then
				Disinfect(v)
				done = true
			end
		end
	end

end
ScanForBadTxt()